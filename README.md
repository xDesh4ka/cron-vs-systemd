# cron-vs-systemd
# Планировщик задач Cron в Linux
  
Cron — это системный демон в операционных системах семейства Unix и Linux, который запускает заранее запланированные задачи в определённые моменты времени, что позволяет автоматизировать процессы и выполнять скрипты без необходимости прямого вмешательства пользователя. Этот механизм является фундаментальным инструментом администрирования систем и автоматизации, поскольку он обеспечивает возможность создания отказоустойчивых и надёжных систем, которые могут выполнять критически важные операции в заданное время.

## 1. Механизм работы Cron

### 1.1 Архитектура и основные компоненты

Cron состоит из нескольких ключевых компонентов, которые взаимодействуют между собой для обеспечения функционирования системы планирования задач. Демон `crond` (или `cron`) постоянно работает в фоновом режиме и проверяет таблицу расписания (crontab) примерно каждую минуту, поскольку минута является минимальной единицей времени, которая поддерживается этой системой. Когда текущее время совпадает с временем, указанным в одной из записей crontab, демон инициирует выполнение соответствующей команды или скрипта с правами пользователя, чьей crontab была задана эта запись.

### 1.2 Типы crontab

В системе Linux существует несколько типов таблиц расписания, которые имеют различные уровни привилегий и область применения:

- **Пользовательские crontab** — хранятся в каталоге `/var/spool/cron/crontabs/` (на некоторых системах `/var/spool/cron/`) и содержат задачи, которые будут выполняться с правами конкретного пользователя. Каждый пользователь может иметь собственный crontab файл, который хранит его личные плановые задачи.

- **Системный crontab** — размещается в файле `/etc/crontab` и позволяет администратору системы добавлять задачи, которые будут выполняться с правами конкретного пользователя (указываемого в записи). Этот файл имеет расширенный формат, включающий имя пользователя в качестве одного из полей.

- **Системные каталоги** — это структурированные каталоги (`/etc/cron.d/`, `/etc/cron.daily/`, `/etc/cron.hourly/`, `/etc/cron.weekly/`, `/etc/cron.monthly/`), в которых администраторы могут размещать скрипты, предназначенные для выполнения в определённые интервалы времени. Такая организация обеспечивает лучшую структурированность и упрощает управление системными задачами.

### 1.3 Процесс выполнения задач

Когда демон cron инициирует выполнение задачи, происходит следующая последовательность событий: сначала cron выполняет fork (создание дочернего процесса) и запускает команду в контексте этого нового процесса, далее обеспечивается правильная установка переменных окружения (USER, HOME, SHELL, PATH и другие), затем выполняется сама команда или скрипт, и, в конечном итоге, любые выходные данные (stdout и stderr) по умолчанию отправляются пользователю по электронной почте, если система настроена на отправку этих уведомлений.

## 2. Формат записей в Crontab

### 2.1 Структура строки crontab

  Каждая строка в файле crontab (за исключением комментариев и пустых строк) содержит ровно пять полей времени и одно поле для команды, которые разделены пробелами или табуляциями, что позволяет системе однозначно интерпретировать каждое поле:

```

┌─────────── минута (0 - 59)

│ ┌───────── час (0 - 23)

│ │ ┌─────── день месяца (1 - 31)

│ │ │ ┌───── месяц (1 - 12) [или JAN-DEC]

│ │ │ │ ┌─── день недели (0 - 7) [или MON-SUN; 0 и 7 = воскресенье]

│ │ │ │ │

│ │ │ │ │

* * * * * /путь/к/команде или скрипту

```

Символы обозначения в формате cron имеют специальные значения, которые позволяют создавать гибкие и мощные выражения для планирования:

- **`*`** (астериск) — означает "любое значение" в указанном диапазоне, то есть выполнить во все возможные значения этого поля.
- **`,`** (запятая) — используется для перечисления конкретных значений, между которыми следует выполнить задачу.  
- **`-`** (дефис) — определяет диапазон значений, указывая, что задача должна выполняться во всех минутах, часах или днях в пределах этого диапазона.
- **`/`** (слэш) — используется для определения шага (интервала), например, `*/5` означает "каждые 5 единиц времени".
- **`?`** (вопросительный знак) — используется только в полях "день месяца" и "день недели" для обозначения "без конкретного значения", что предотвращает конфликты между этими двумя полями.
### 2.2 Примеры cron выражений

Следующие примеры демонстрируют различные способы использования синтаксиса cron для создания расписаний различной сложности:

#### Простые примеры
**Пример 1:** Выполнить задачу каждый день в полночь (00:00)

```

0 0 * * * /usr/local/bin/backup.sh

```

Это выражение указывает, что команда будет запущена в 0-ю минуту 0-го часа каждого дня месяца в любой месяц и в любой день недели.

**Пример 2:** Выполнить задачу каждый час в начале часа

```

0 * * * * /home/user/script.sh

```

Данное выражение означает, что скрипт будет выполняться в 0-ю минуту каждого часа суток.

#### Средние примеры  

**Пример 1:** Выполнить задачу в определённые дни недели (понедельник и среда)

```
0 9 * * 1,3 /home/admin/weekly_report.sh
```
Это выражение запускает задачу в 09:00 по понедельникам (1) и средам (3).

**Пример 2:** Выполнить задачу в определённые дни месяца (1-е и 15-е число)

```
0 0 1,15 * * /var/log/monthly_cleanup.sh
```

Данное выражение указывает на запуск задачи в полночь в первый и пятнадцатый день каждого месяца.

**Пример 3:** Выполнить задачу каждый день, кроме выходных (с понедельника по пятницу)

```
0 8 * * 1-5 /home/user/workday_task.sh
```

Это выражение означает, что задача будет запущена в 08:00 с понедельника по пятницу.

#### Сложные примеры

**Пример 1:** Выполнить задачу каждые 15 минут в рабочее время (9:00-17:00) в дни недели (пн-пт)

```

*/15 9-17 * * 1-5 /home/user/frequent_check.sh

```

Это выражение создаёт задачу, которая запускается каждые 15 минут в интервале с 09:00 до 17:00 с понедельника по пятницу, при этом последний запуск будет ровно в 17:00.


**Пример 2:** Выполнить задачу в каждый день кроме праздников (здесь используется только стандартный формат, праздники требуют дополнительной логики в скрипте)

```
0 0 * * * [ $(date +\%w) -ne 0 ] && /opt/app/daily_task.sh
```

Данное выражение содержит условие, которое проверяет, не является ли текущий день воскресеньем (день недели 0), и только если это так, выполняет задачу.

**Пример 3:** Выполнить задачу первый день каждого месяца в 02:30

```
30 2 1 * * /root/monthly_maintenance.sh
```
Это выражение указывает на запуск задачи в 02:30 первого числа каждого месяца.

**Пример 4:** Выполнить задачу каждый день в рабочее время каждый час (09:00, 10:00, ..., 17:00)

```

0 9-17 * * * /home/user/hourly_check.sh

```

Данное выражение запускает задачу в начале каждого часа с 09:00 до 17:00.

## 3. Управление Crontab

### 3.1 Основные команды

Работа с таблицей расписания cron осуществляется через командную строку с использованием специальной утилиты, которая предоставляет полный набор операций для управления плановыми задачами:

**Просмотр текущего crontab пользователя:**

```bash
crontab -l
```

Эта команда выводит содержимое crontab файла текущего пользователя, позволяя увидеть все запланированные задачи.


**Редактирование crontab:**

```bash
crontab -e
```

Команда открывает crontab файл в текстовом редакторе (обычно nano или vi), который определён переменной окружения EDITOR, позволяя добавлять, удалять или изменять существующие задачи.

  
**Установка crontab из файла:**

```bash
crontab /path/to/crontab_file
```

Эта команда полностью заменяет текущий crontab пользователя содержимым из указанного файла, что удобно для автоматизации и развёртывания конфигураций.

**Удаление crontab пользователя:**

```bash
crontab -r
```

Команда удаляет весь crontab пользователя, что делает её опасной операцией, требующей осторожности.  

### 3.2 Контроль доступа к Cron

Система предоставляет механизм контроля доступа для определения того, какие пользователи могут использовать cron функциональность, что обеспечивает безопасность и предотвращает неправомерное использование ресурсов системы:

- **`/etc/cron.allow`** — файл, содержащий список пользователей, которым разрешено использовать cron. Если этот файл существует, только пользователи, перечисленные в нём, могут создавать и редактировать свои crontab файлы.

- **`/etc/cron.deny`** — файл, содержащий список пользователей, которым запрещено использовать cron. Этот файл используется только в том случае, если файл `/etc/cron.allow` не существует.

Если оба файла отсутствуют, обычно это означает, что все пользователи (кроме некоторых системных пользователей) имеют право использовать cron.


## 4. Практическое руководство: Создание Bash скрипта для запуска через Cron

### 4.1 Пошаговая инструкция

#### Шаг 1: Создание директории для скриптов  

Первым делом необходимо выбрать подходящее местоположение для хранения скриптов, которые будут выполняться через cron, что обеспечит лучшую организацию и упростит управление задачами. Рекомендуется создать директорию в домашней папке пользователя или в системной директории для скриптов, если у пользователя есть соответствующие права:

```bash
# Создание директории в домашней папке
mkdir -p ~/cron_scripts
# Или создание системной директории для скриптов (требует прав администратора)
sudo mkdir -p /opt/cron_scripts
```
#### Шаг 2: Создание Bash скрипта для отправки curl запроса

Создайте файл со следующим содержимым, используя текстовый редактор (nano, vim или другой на ваше усмотрение), который будет содержать логику для отправки HTTP запроса на указанный URL:

```bash
nano ~/cron_scripts/send_request.sh
```

**Содержимое скрипта `send_request.sh`:**

```bash
#!/bin/bash

# Переменная с целевым URL, на который следует отправить запрос
TARGET_URL="https://api.example.com/webhook"

# Отправка GET запроса на указанный URL с использованием curl
# Флаг -s подавляет вывод прогресса скачивания
# Флаг -w выводит информацию о коде ответа HTTP
curl -s -w "\nHTTP Status: %{http_code}\n" "$TARGET_URL" >> /var/log/cron_requests.log 2>&1

# Альтернативный вариант с добавлением текущего времени в логирование
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Request sent to $TARGET_URL" >> /var/log/cron_requests.log

# Код выхода 0 означает успешное выполнение
exit 0
```

Этот скрипт является простым и понятным примером, который демонстрирует основные принципы работы с curl в контексте cron задач, при этом включая логирование для отладки.
#### Шаг 3: Предоставление прав на выполнение

После создания скрипта необходимо предоставить ему права на выполнение, что позволит операционной системе распознать его как исполняемый файл:

```bash
# Предоставление прав на выполнение для владельца файла
chmod +x ~/cron_scripts/send_request.sh

# Проверка прав (должна быть буква 'x' в одной из групп прав)
ls -la ~/cron_scripts/send_request.sh
```

Правильный вывод должен выглядеть примерно так:

```
-rwxr-xr-x 1 username username 345 Dec 03 12:00 send_request.sh
```

#### Шаг 4: Тестирование скрипта
Перед добавлением скрипта в crontab важно убедиться, что он работает корректно в интерактивном режиме, что предотвратит потенциальные проблемы при автоматическом выполнении:

  

```bash
# Прямое выполнение скрипта
~/cron_scripts/send_request.sh

# Или с явным указанием интерпретатора
bash ~/cron_scripts/send_request.sh

# Проверка кода выхода (должен быть 0 при успехе)
echo $?
```

#### Шаг 5: Добавление задачи в Crontab
Когда скрипт успешно протестирован, его следует добавить в crontab пользователя, чтобы он выполнялся в определённое время в соответствии с расписанием:
  
```bash
# Открытие редактора crontab
crontab -e
```

Добавьте следующую строку в открывшийся редактор (в конец файла), которая указывает системе запускать скрипт каждые 5 минут:

```
*/5 * * * * /home/username/cron_scripts/send_request.sh
```

Если вы хотите запустить скрипт в определённое время, используйте соответствующее выражение, например для запуска каждый день в 09:00:

```
0 9 * * * /home/username/cron_scripts/send_request.sh
```

**Примечание:** Убедитесь, что путь к скрипту указан правильно и полностью (абсолютный путь), а не относительный путь, поскольку cron не имеет понимания о текущей директории пользователя.

#### Шаг 6: Сохранение и проверка

После добавления строки в редактор, сохраните файл (в nano это Ctrl+O, Enter, Ctrl+X; в vi это :wq):  

```bash
# Проверка добавленной задачи
crontab -l
```

Команда должна вывести содержимое crontab, включая добавленную строку, что подтвердит успешное добавление задачи в расписание.

---
## Systemd

Systemd представляет собой инновационную систему инициализации и управления сервисами операционной системы Linux, которая, являясь более современной альтернативой традиционной системе init (SysVinit), обеспечивает значительно более быстрый запуск системы, параллельное выполнение сервисов и более гибкую конфигурацию зависимостей между ними. Важно отметить, что systemd не только управляет сервисами, но также контролирует монтирование файловых систем, управляет системным журналированием через journald, осуществляет контроль пользовательских сессий и предоставляет множество других функций, которые ранее выполнялись отдельными инструментами.

## Часть 1: Механизм работы systemd

### 1.1. Основная архитектура

Systemd работает на основе концепции "unit" (единиц), где каждая единица представляет собой ресурс, которым может управлять systemd, и эти единицы описываются в специальных конфигурационных файлах с расширением .service, .timer, .target, .socket и другими, каждый из которых предназначен для определённого типа ресурса. Главным демоном systemd является systemd (PID 1), который запускается ядром Linux в первую очередь и является предком всех остальных процессов в системе.

Архитектура systemd включает в себя следующие компоненты:

1. **systemd (init-система)** — основной демон, отвечающий за инициализацию системы и управление сервисами
2. **systemctl** — утилита командной строки для управления systemd и его unit'ами
3. **journald** — демон логирования, собирающий логи от всех сервисов
4. **logind** — демон, управляющий пользовательскими сессиями и устройствами
5. **networkd** — опциональный демон управления сетевыми интерфейсами
6. **resolved** — демон разрешения имён DNS

### 1.2. Жизненный цикл сервиса

Когда вы запускаете сервис через systemctl, systemd проходит следующие этапы, которые можно описать как последовательную цепь переходов между состояниями, где каждое состояние определяет текущий статус сервиса:

1. **inactive** — начальное состояние, в котором сервис не запущен
2. **activating** — состояние переходного периода, в котором systemd выполняет команду StartExec для запуска сервиса
3. **active (running)** — состояние, в котором сервис успешно запущен и исполняется
4. **deactivating** — состояние, в котором systemd выполняет команду StopExec и завершает процесс сервиса
5. **failed** — состояние, в которое переходит сервис, если он завершился с ошибкой или не запустился

### 1.3. Структура unit-файла для сервиса

Unit-файл systemd представляет собой INI-подобный конфигурационный файл, который содержит множество секций, каждая из которых отвечает за определённый аспект работы сервиса, и имеет следующую структуру:

```ini
[Unit]
Description=Описание сервиса
After=network.target
Wants=другой-сервис.service

[Service]
Type=simple
User=имя-пользователя
WorkingDirectory=/путь/к/директории
ExecStart=/путь/к/скрипту
ExecReload=/команда/перезагрузки
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

### 1.4. Ключевые секции и параметры

#### Секция [Unit]

- **Description** — текстовое описание сервиса, которое будет отображаться в systemctl
- **Documentation** — ссылка на документацию (может быть man: или http://)
- **After** — указывает, после каких unit'ов должен стартовать данный сервис; это гарантирует порядок запуска
- **Before** — указывает, перед какими unit'ами должен стартовать данный сервис
- **Wants** — мягкая зависимость; если указанный unit не запустится, это не повлияет на запуск текущего сервиса
- **Requires** — жёсткая зависимость; если указанный unit не запустится, текущий сервис также не запустится
- **ConditionPathExists** — условие для запуска; сервис запустится только если путь существует

#### Секция [Service]

- **Type** — определяет тип сервиса:
  - `simple` — процесс остаётся в памяти после запуска (по умолчанию)
  - `forking` — процесс создаёт дочерний процесс и завершает работу; дочерний процесс продолжает работу
  - `oneshot` — процесс выполняется один раз и завершается; используется для настроечных скриптов
  - `notify` — процесс отправляет systemd сигнал готовности
  - `dbus` — сервис представляет собой D-Bus сервис

- **User** — пользователь, от которого будет запущен сервис
- **Group** — группа, от которой будет запущен сервис
- **WorkingDirectory** — рабочая директория для процесса
- **ExecStart** — команда для запуска сервиса
- **ExecStartPre** — команды, выполняемые перед запуском основного сервиса
- **ExecStartPost** — команды, выполняемые после запуска основного сервиса
- **ExecStop** — команда для остановки сервиса
- **ExecReload** — команда для перезагрузки конфигурации без перезапуска сервиса
- **Restart** — политика перезапуска:
  - `no` — не перезапускать (по умолчанию)
  - `always` — всегда перезапускать независимо от кода завершения
  - `on-success` — перезапускать только при успешном завершении (код 0)
  - `on-failure` — перезапускать только если процесс завершился с ошибкой
  - `on-abnormal` — перезапускать при ненормальном завершении (сигнал, таймаут)
  - `on-watchdog` — перезапускать если watchdog сработал
  - `on-abort` — перезапускать если процесс был прерван сигналом

- **RestartSec** — задержка в секундах перед перезапуском сервиса
- **StandardOutput** — где перенаправлять стандартный вывод (journal, null, file и т.д.)
- **StandardError** — где перенаправлять стандартный вывод ошибок

#### Секция [Install]

- **WantedBy** — указывает, какие target'ы "хотят" этот unit; используется при enable сервиса
- **RequiredBy** — жёсткая зависимость для других unit'ов
- **Alias** — альтернативные имена для unit'а

### 1.5. Состояния и переходы

Systemd отслеживает состояние каждого сервиса, и понимание этих состояний критически важно для диагностики проблем. Каждый сервис может находиться в одном из следующих состояний:

- **loaded** — unit-файл был прочитан и распарсен systemd
- **active** — сервис работает
- **inactive** — сервис не работает
- **failed** — попытка запуска не удалась
- **reloading** — сервис перезагружает свою конфигурацию
- **activating** — systemd в процессе запуска сервиса
- **deactivating** — systemd в процессе остановки сервиса

Кроме того, systemd различает **enabled** и **disabled** статусы, которые определяют, будет ли сервис автоматически запущен при загрузке системы.

## Часть 2: Работа с таймерами и cron-подобные выражения

### 2.1. Таймеры systemd вместо cron

В то время как традиционный cron является отдельным демоном для планирования задач, systemd предоставляет встроенный механизм таймеров через unit-файлы с расширением .timer, которые позволяют планировать выполнение сервисов с большей гибкостью и интеграцией с системой логирования.

Преимущества таймеров systemd перед cron:

1. Логирование через journald вместо отправки писем по email
2. Возможность ограничения ресурсов (CPU, память)
3. Лучшая интеграция с сервисами и их зависимостями
4. Возможность выполнения даже если таймер был пропущен

### 2.2. Синтаксис таймеров systemd

Таймеры systemd используют более сложный синтаксис, нежели простые выражения cron, хотя они поддерживают как абсолютные, так и относительные временные точки:

```ini
[Timer]
OnBootSec=1min
OnUnitActiveSec=1h
Persistent=true
```

#### Основные параметры

- **OnBootSec** — выполнить через указанное время после загрузки системы
- **OnUnitActiveSec** — выполнить через указанное время после последнего успешного запуска сервиса
- **OnUnitInactiveSec** — выполнить через указанное время после последнего завершения сервиса
- **OnCalendar** — планировать на основе календарного расписания (ближе всего к cron)
- **Persistent** — если установлено в true, таймер помнит время последнего срабатывания и может компенсировать пропущенные запуски
- **AccuracySec** — точность таймера; по умолчанию 1 минута

### 2.3. Синтаксис OnCalendar (cron-подобные выражения)

Параметр **OnCalendar** использует специальный формат, который напоминает традиционный синтаксис cron, но более гибкий:

```
DayOfWeek Year-Month-Day Hour:Minute:Second
```

Примеры:

1. **Каждый день в 15:30**
   ```
   OnCalendar=*-*-* 15:30:00
   ```

2. **Каждый понедельник в 10:00**
   ```
   OnCalendar=Mon *-*-* 10:00:00
   ```

3. **Первого числа каждого месяца в 00:00**
   ```
   OnCalendar=*-*-01 00:00:00
   ```

4. **Каждые 15 минут**
   ```
   OnCalendar=*-*-* *:0/15:00
   ```

5. **Во вторник и четверг в 14:30**
   ```
   OnCalendar=Tue,Thu *-*-* 14:30:00
   ```

6. **Каждый час в начале часа**
   ```
   OnCalendar=*-*-* *:00:00
   ```
### 2.4. Сравнение с cron

| Задача | Cron | Systemd Timer |
|--------|------|---------------|
| Каждый день в 15:30 | `30 15 * * *` | `OnCalendar=*-*-* 15:30:00` |
| Каждый понедельник в 10:00 | `0 10 * * 1` | `OnCalendar=Mon *-*-* 10:00:00` |
| Первого числа месяца | `0 0 1 * *` | `OnCalendar=*-*-01 00:00:00` |
| Каждые 15 минут | `*/15 * * * *` | `OnUnitActiveSec=15min` |
| По четным часам в 30 минут | `30 */2 * * *` | `OnCalendar=*-*-* 0..22/2:30:00` |

## Часть 3: Создание собственного bash-скрипта

### 3.1. Создание простого скрипта с curl запросом

Ниже представлен простой bash-скрипт, который отправляет GET-запрос на указанный URL, обрабатывает ошибки и логирует результаты:

```bash
#!/bin/bash

# Скрипт отправляет GET-запрос на указанный URL
# Использование: ./send-request.sh URL [TIMEOUT]

set -o pipefail

# Переменные
URL="${1:-https://example.com/api/status}"
TIMEOUT="${2:-10}"
LOG_FILE="/var/log/send-request.log"

# Проверка наличия curl
if ! command -v curl &> /dev/null; then
    echo "ERROR: curl не установлен" | tee -a "$LOG_FILE"
    exit 1
fi

# Проверка URL
if [[ -z "$URL" ]]; then
    echo "ERROR: URL не указан" | tee -a "$LOG_FILE"
    exit 1
fi

# Функция логирования с временной меткой
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Выполнение curl запроса
HTTP_CODE=$(curl -s -o /tmp/response.txt -w "%{http_code}" \
    --max-time "$TIMEOUT" \
    --connect-timeout 5 \
    "$URL")

# Обработка результата
if [[ "$HTTP_CODE" -eq 200 ]]; then
    log_message "SUCCESS: Получен код ответа $HTTP_CODE для $URL"
    exit 0
elif [[ "$HTTP_CODE" -eq 0 ]]; then
    log_message "ERROR: Timeout или ошибка соединения при запросе к $URL"
    exit 1
else
    log_message "WARNING: Получен код ответа $HTTP_CODE для $URL"
    exit 1
fi
```

### 3.2. Объяснение скрипта

Данный скрипт выполняет следующие функции, которые можно описать как последовательность логических операций:

1. **Инициализация переменных** — устанавливаются URL (с значением по умолчанию) и таймаут соединения
2. **Проверка зависимостей** — скрипт проверяет наличие команды curl в системе
3. **Валидация входных данных** — проверяется, что URL был передан
4. **Логирование** — все события записываются в файл журнала с временными метками
5. **Выполнение запроса** — curl отправляет GET-запрос с установленным таймаутом
6. **Обработка результатов** — анализируется HTTP-код ответа и принимается соответствующее решение

Флаг `set -o pipefail` гарантирует, что скрипт вернёт правильный код ошибки, даже если часть pipeline завершилась с ошибкой.

## Часть 4: Пошаговая инструкция по созданию и запуску сервиса

### 4.1.  Создание bash-скрипта

Следуя этапам, представленным ниже, можно создать рабочий сервис:

1. Создайте директорию для скриптов:
   ```bash
   sudo mkdir -p /opt/scripts
   ```

2. Создайте файл скрипта:
   ```bash
   sudo nano /opt/scripts/send-request.sh
   ```

3. Вставьте содержимое скрипта (из раздела 3.1) и сохраните файл (Ctrl+O, Enter, Ctrl+X)

4. Сделайте скрипт исполняемым:
   ```bash
   sudo chmod +x /opt/scripts/send-request.sh
   ```

5. Создайте директорию для логов (если её нет):
   ```bash
   sudo mkdir -p /var/log
   sudo chmod 755 /var/log
   ```

6. Убедитесь, что скрипт работает, запустив его вручную:
   ```bash
   sudo /opt/scripts/send-request.sh "https://example.com/api/status" 5
   ```

### 4.2. Создание unit-файла для сервиса

1. Создайте unit-файл systemd:
   ```bash
   sudo nano /etc/systemd/system/send-request.service
   ```

2. Вставьте следующее содержимое:
   ```ini
   [Unit]
   Description=Send HTTP Request Service
   Documentation=man:curl(1)
   After=network-online.target
   Wants=network-online.target

   [Service]
   Type=oneshot
   User=root
   ExecStart=/opt/scripts/send-request.sh "https://example.com/api/status" 10
   StandardOutput=journal
   StandardError=journal
   TimeoutStartSec=30

   [Install]
   WantedBy=multi-user.target```

3. Сохраните файл
### 4.3.  Создание таймера для периодического запуска

1. Создайте timer-файл:
   ```bash
   sudo nano /etc/systemd/system/send-request.timer
   ```

2. Вставьте следующее содержимое:
   ```ini
   [Unit]
   Description=Timer for Send HTTP Request Service
   Requires=send-request.service
   Documentation=https://www.freedesktop.org/software/systemd/man/systemd.timer.html

   [Timer]
   OnBootSec=2min
   OnUnitActiveSec=30min
   Persistent=true
   Unit=send-request.service

   [Install]
   WantedBy=timers.target
   ````

3. Сохраните файл
### 4.4. Перезагрузка конфигурации systemd

После создания unit-файлов необходимо уведомить systemd о новых конфигурациях:

```bash
sudo systemctl daemon-reload
```

### 4.5. Запуск и включение сервиса и таймера

1. Запустите таймер:
   ```bash
   sudo systemctl start send-request.timer
   ```

2. Включите таймер для автозапуска при загрузке системы:
   ```bash
   sudo systemctl enable send-request.timer
   ```

3. Проверьте статус таймера:
   ```bash
   sudo systemctl status send-request.timer
   ```

4. Просмотрите список активных таймеров:
   ```bash
   sudo systemctl list-timers --all
   ```

### 4.6.  Мониторинг и отладка

Для проверки логов выполнения сервиса используйте journalctl:

```bash
# Просмотреть логи последних 50 строк
sudo journalctl -u send-request.service -n 50

# Просмотреть логи в реальном времени
sudo journalctl -u send-request.service -f

# Просмотреть логи таймера
sudo journalctl -u send-request.timer -n 20

# Просмотреть логи за последний час
sudo journalctl -u send-request.service --since "1 hour ago"
```

Кроме того, вы можете проверить файл логов, который создан самим скриптом:

```bash
sudo tail -f /var/log/send-request.log
```

### 4.7. Управление сервисом и таймером

```bash
# Остановить таймер
sudo systemctl stop send-request.timer

# Отключить таймер от автозапуска
sudo systemctl disable send-request.timer

# Перезагрузить конфигурацию (если вы изменили unit-файл)
sudo systemctl daemon-reload

# Перезапустить таймер
sudo systemctl restart send-request.timer

# Проверить статус конкретного сервиса
sudo systemctl status send-request.service

# Принудительно запустить сервис сейчас
sudo systemctl start send-request.service
```

Systemd представляет собой мощный инструмент управления сервисами в современных дистрибутивах Linux, который, благодаря своей гибкости и интеграции с системой, позволяет администраторам и разработчикам эффективно управлять жизненным циклом приложений. Овладение навыками работы с systemd критически важно для специалистов, которые занимаются администрированием Linux-систем, разработкой серверных приложений, или внедрением инфраструктуры как кода (Infrastructure as Code).
